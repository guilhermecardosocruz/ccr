
===== app/api/pin-login/route.ts =====
1 import prisma from "@/lib/prisma";
2 import { sha256 } from "@/lib/crypto";
3 
4 export const runtime = "nodejs";
5 export const dynamic = "force-dynamic";
6 
7 function normalizePin(s: string) {
8   return String(s || "").replace(/[\s-]+/g, "").toUpperCase().trim();
9 }
10 
11 export async function POST(req: Request) {
12   try {
13     const { pin } = await req.json();
14     const raw = String(pin ?? "");
15     const p = normalizePin(raw);
16     if (!p) {
17       return new Response(JSON.stringify({ ok: false, error: "missing_pin" }), { status: 400 });
18     }
19 
20     // 1) PIN Mestre por ENV (plaintext, normalizado)
21     const envMaster = normalizePin(process.env.ADMIN_MASTER_PIN || "");
22     if (envMaster && p === envMaster) {
23       return Response.json({ ok: true, role: "admin", eventId: null });
24     }
25 
26     // 2) Admin hash salvo no banco — compara como HEX
27     const hashHex = sha256(p).toString("hex");
28     const admin = await prisma.appSetting.findUnique({ where: { key: "admin_pin_hash" } });
29     if (admin?.value && admin.value === hashHex) {
30       return Response.json({ ok: true, role: "admin", eventId: null });
31     }
32 
33     // 3) PINs de evento (juiz/coord) — compara como HEX
34     const pinsList = await prisma.eventPins.findMany({
35       select: { eventId: true, judgeHash: true, coordHash: true },
36     });
37     for (const row of pinsList) {
38       if (row.judgeHash && row.judgeHash === hashHex) {
39         return Response.json({ ok: true, role: "judge", eventId: row.eventId });
40       }
41       if (row.coordHash && row.coordHash === hashHex) {
42         return Response.json({ ok: true, role: "coord", eventId: row.eventId });
43       }
44     }
45 
46     return new Response(JSON.stringify({ ok: false, error: "invalid_pin" }), { status: 401 });
47   } catch (e) {
48     console.error("pin-login error:", e);
49     return new Response(JSON.stringify({ ok: false, error: "bad_request" }), { status: 400 });
50   }
51 }

===== app/api/admin-pin/route.ts =====
1 import prisma from "@/lib/prisma";
2 import { sha256Hex, genAlphaNum } from "@/lib/crypto";
3 
4 export const runtime = "nodejs";
5 export const dynamic = "force-dynamic";
6 
7 // GET: informa se existe configuração (ENV ou banco)
8 export async function GET() {
9   const hasEnv = Boolean(process.env.ADMIN_MASTER_PIN?.trim());
10   if (hasEnv) {
11     return Response.json({ ok: true, configured: true, source: "env" });
12   }
13   const row = await prisma.appSetting.findUnique({ where: { key: "admin_pin_hash" } });
14   return Response.json({ ok: true, configured: Boolean(row?.value), source: "db" });
15 }
16 
17 // POST / PUT: cria ou rotaciona o PIN do admin
18 export async function POST(req: Request) {
19   return handleUpsert(req);
20 }
21 export async function PUT(req: Request) {
22   return handleUpsert(req);
23 }
24 
25 async function handleUpsert(req: Request) {
26   try {
27     const hasEnv = Boolean(process.env.ADMIN_MASTER_PIN?.trim());
28     if (hasEnv) {
29       // Se há PIN mestre via ENV, evita sobrescrever
30       return new Response(JSON.stringify({ ok: false, error: "env_master_pin_in_use" }), { status: 409 });
31     }
32 
33     const body = await req.json().catch(() => ({}));
34     let adminPin: string | undefined = body.adminPin ? String(body.adminPin).trim() : undefined;
35 
36     if (body.rotate || !adminPin) {
37       adminPin = genAlphaNum(10);
38     }
39 
40     await prisma.appSetting.upsert({
41       where: { key: "admin_pin_hash" },
42       create: { key: "admin_pin_hash", value: sha256Hex(adminPin) },
43       update: { value: sha256Hex(adminPin) },
44     });
45 
46     return Response.json({ ok: true, adminPin });
47   } catch (e) {
48     console.error("Erro em admin-pin:", e);
49     return new Response(JSON.stringify({ ok: false, error: "bad_request" }), { status: 400 });
50   }
51 }

===== app/api/events/route.ts =====
1 import prisma from "@/lib/prisma";
2 import { sha256Hex, genNumeric, genAlphaNum } from "@/lib/crypto";
3 
4 export const runtime = "nodejs";
5 export const dynamic = "force-dynamic";
6 
7 // GET: lista eventos (id, name)
8 export async function GET() {
9   const rows = await prisma.event.findMany({
10     select: { id: true, name: true, createdAt: true, archived: true },
11     orderBy: { createdAt: "desc" },
12   });
13   return Response.json(rows);
14 }
15 
16 // POST: cria evento e já gera PINs padrão (retorna PINs em texto apenas nessa resposta)
17 export async function POST(req: Request) {
18   try {
19     const { name } = await req.json();
20     const n = String(name ?? "").trim();
21     if (!n) return new Response(JSON.stringify({ ok: false, error: "invalid_name" }), { status: 400 });
22 
23     const ev = await prisma.event.create({ data: { name: n } });
24 
25     // Gera PINs iniciais
26     const judgePin = genNumeric(6);
27     const coordPin = genAlphaNum(8);
28     await prisma.eventPins.create({
29       data: {
30         eventId: ev.id,
31         judgeHash: sha256Hex(judgePin),
32         coordHash: sha256Hex(coordPin),
33       },
34     });
35 
36     return Response.json({ ok: true, event: { id: ev.id, name: ev.name }, pins: { judgePin, coordPin } });
37   } catch {
38     return new Response(JSON.stringify({ ok: false, error: "bad_request" }), { status: 400 });
39   }
40 }

===== app/api/events/[id]/pins/route.ts =====
1 import prisma from "@/lib/prisma";
2 import { sha256Hex, genAlphaNum, genNumeric } from "@/lib/crypto";
3 
4 export const runtime = "nodejs";
5 export const dynamic = "force-dynamic";
6 
7 // GET: retorna apenas que existem (não expõe plaintext)
8 export async function GET(_req: Request, ctx: any) {
9   const id: string | undefined = ctx?.params?.id;
10   if (!id) return new Response(JSON.stringify({ ok: false, error: "missing_id" }), { status: 400 });
11   const pins = await prisma.eventPins.findUnique({ where: { eventId: id } });
12   const hasJudge = Boolean(pins?.judgeHash);
13   const hasCoord = Boolean(pins?.coordHash);
14   return Response.json({ ok: true, hasJudge, hasCoord, rotatedAt: pins?.rotatedAt ?? null });
15 }
16 
17 /**
18  * POST: rotaciona ou define PINs
19  * body:
20  *  - rotate: boolean (se true, gera novos aleatórios)
21  *  - judgePin?: string  (opcional — define manual)
22  *  - coordPin?: string  (opcional — define manual)
23  * Retorna sempre os PINs em texto APENAS nessa resposta (para copiar).
24  */
25 export async function POST(req: Request, ctx: any) {
26   try {
27     const id: string | undefined = ctx?.params?.id;
28     if (!id) return new Response(JSON.stringify({ ok: false, error: "missing_id" }), { status: 400 });
29 
30     const body = await req.json().catch(() => ({}));
31     let judgePin: string | undefined = body.judgePin ? String(body.judgePin).trim() : undefined;
32     let coordPin: string | undefined = body.coordPin ? String(body.coordPin).trim() : undefined;
33 
34     if (body.rotate) {
35       judgePin = genNumeric(6);
36       coordPin = genAlphaNum(8);
37     }
38     if (!judgePin && !coordPin) {
39       return new Response(JSON.stringify({ ok: false, error: "nothing_to_set" }), { status: 400 });
40     }
41 
42     await prisma.eventPins.upsert({
43       where: { eventId: id },
44       create: {
45         eventId: id,
46         judgeHash: judgePin ? sha256Hex(judgePin) : null,
47         coordHash: coordPin ? sha256Hex(coordPin) : null,
48       },
49       update: {
50         judgeHash: judgePin ? sha256Hex(judgePin) : undefined,
51         coordHash: coordPin ? sha256Hex(coordPin) : undefined,
52         rotatedAt: new Date(),
53       },
54     });
55 
56     return Response.json({ ok: true, pins: { judgePin, coordPin } });
57   } catch {
58     return new Response(JSON.stringify({ ok: false, error: "bad_request" }), { status: 400 });
59   }
60 }

===== lib/crypto.ts =====
1 import { randomBytes, createHash } from "crypto";
2 
3 /**
4  * Gera o hash SHA-256 em HEX de uma string.
5  * Uso: sha256Hex("123456") -> "8d969eef6ecad3c29a3a629280e686cff8..."
6  */
7 export function sha256Hex(input: string): string {
8   return createHash("sha256").update(input, "utf8").digest("hex");
9 }
10 
11 /**
12  * Versão básica (mantida por compatibilidade, caso alguém já importe 'sha256').
13  * Retorna o Buffer do hash; prefira sha256Hex para comparar/armazenar.
14  */
15 export function sha256(input: string): Buffer {
16   return createHash("sha256").update(input, "utf8").digest();
17 }
18 
19 /** Alfabeto para PIN alfanumérico (A-Z e 0-9 sem caracteres ambíguos) */
20 const ALPHA_NUM = "ABCDEFGHJKLMNPQRSTUVWXYZ23456789";
21 /** Alfabeto numérico */
22 const NUM = "0123456789";
23 
24 /**
25  * PIN numérico com tamanho fixo (ex.: 6 -> "493027")
26  */
27 export function genNumeric(len = 6): string {
28   if (len <= 0) return "";
29   const bytes = randomBytes(len);
30   let out = "";
31   for (let i = 0; i < len; i++) {
32     out += NUM[bytes[i] % NUM.length];
33   }
34   return out;
35 }
36 
37 /**
38  * PIN alfanumérico com tamanho fixo (ex.: 8 -> "AP7G2K9M")
39  */
40 export function genAlphaNum(len = 8): string {
41   if (len <= 0) return "";
42   const bytes = randomBytes(len);
43   let out = "";
44   for (let i = 0; i < len; i++) {
45     out += ALPHA_NUM[bytes[i] % ALPHA_NUM.length];
46   }
47   return out;
48 }
49 
50 /**
51  * Compare hash em HEX (tempo constante aproximado).
52  */
53 export function equalsHex(a: string, b: string): boolean {
54   if (a.length !== b.length) return false;
55   // comparação de tempo constante aproximada
56   let diff = 0;
57   for (let i = 0; i < a.length; i++) diff |= a.charCodeAt(i) ^ b.charCodeAt(i);
58   return diff === 0;
59 }

===== lib/prisma.ts =====
1 import { PrismaClient } from "@prisma/client";
2 
3 // Evita múltiplas instâncias em dev (Hot Reload)
4 const globalForPrisma = globalThis as unknown as { prisma?: PrismaClient };
5 
6 export const prisma =
7   globalForPrisma.prisma ??
8   new PrismaClient({
9     log: process.env.NODE_ENV === "development" ? ["query", "error", "warn"] : ["error"],
10   });
11 
12 if (process.env.NODE_ENV === "development") {
13   globalForPrisma.prisma = prisma;
14 }
15 
16 export default prisma;

===== lib/session.ts =====
1 import { loadJSON, saveJSON, removeKey } from "./storage";
2 
3 export type Role = "admin"|"judge"|"coord";
4 export type Session = {
5   authed: boolean;
6   role: Role|null;
7   pin: string|null;       // PIN digitado (admin ou do evento)
8   eventId: string|null;   // evento ativo (admin pode alternar)
9 };
10 const KEY = "ccr-session";
11 
12 export function getSession(): Session {
13   return loadJSON<Session>(KEY, { authed:false, role:null, pin:null, eventId:null });
14 }
15 export function setSession(s: Session) { saveJSON(KEY, s); }
16 export function clearSession() { removeKey(KEY); }
17 export function requireEventId(): string|null {
18   const s = getSession(); return s.eventId;
19 }

===== prisma/schema.prisma =====
1 generator client {
2   provider = "prisma-client-js"
3 }
4 
5 datasource db {
6   provider  = "postgresql"
7   url       = env("DATABASE_URL")
8   directUrl = env("DIRECT_URL")
9 }
10 
11 model Event {
12   id        String   @id @default(cuid())
13   name      String
14   archived  Boolean  @default(false)
15   createdAt DateTime @default(now())
16 
17   pins  EventPins?
18   teams Team[]
19   runs  Run[]
20 
21   @@index([createdAt])
22 }
23 
24 model EventPins {
25   eventId   String   @id
26   judgeHash String?
27   coordHash String?
28   rotatedAt DateTime @default(now())
29 
30   event Event @relation(fields: [eventId], references: [id], onDelete: Cascade)
31 }
32 
33 model Team {
34   id        String   @id @default(cuid())
35   eventId   String
36   name      String
37   school    String?
38   category  String?
39   createdAt DateTime @default(now())
40 
41   event Event @relation(fields: [eventId], references: [id], onDelete: Cascade)
42   runs  Run[]
43 
44   @@unique([eventId, name])
45   @@index([eventId])
46   @@index([createdAt])
47 }
48 
49 model Run {
50   id        String   @id @default(cuid())
51   eventId   String
52   teamId    String
53   score     Decimal  @db.Decimal(10, 2)
54   timeSec   Int
55   notes     String?
56   createdAt DateTime @default(now())
57 
58   event Event @relation(fields: [eventId], references: [id], onDelete: Cascade)
59   team  Team  @relation(fields: [teamId], references: [id], onDelete: Cascade)
60 
61   @@index([eventId, teamId, createdAt])
62   @@index([eventId, createdAt])
63 }
64 
65 model AppSetting {
66   key   String @id // ex.: "admin_pin_hash"
67   value String
68 }

===== scripts/seed-admin-pin.mjs =====
1 import 'dotenv/config';
2 import prisma from '../lib/prisma.js';
3 import { sha256Hex } from '../lib/crypto.js';
4 
5 const pin = (process.env.ADMIN_MASTER_PIN || '').trim();
6 if (!pin) {
7   console.error('ADMIN_MASTER_PIN não definido no ambiente.');
8   process.exit(1);
9 }
10 
11 const hash = sha256Hex(pin);
12 
13 try {
14   await prisma.appSetting.upsert({
15     where: { key: 'admin_pin_hash' },
16     create: { key: 'admin_pin_hash', value: hash },
17     update: { value: hash },
18   });
19   console.log('OK: admin_pin_hash gravado/atualizado no banco.');
20 } catch (e) {
21   console.error('ERRO ao gravar admin_pin_hash:', e?.message || e);
22   process.exit(1);
23 } finally {
24   await prisma.$disconnect();
25 }

===== app/login/page.tsx =====
[MISSING] app/login/page.tsx

===== components/RouteGuard.tsx =====
1 "use client";
2 
3 import { useEffect, useState } from "react";
4 import { getSession } from "@/lib/session";
5 import { useRouter } from "next/navigation";
6 
7 export default function RouteGuard({ need, needEvent = false, children }:{
8   need: "any"|"admin"|"judge"|"coord",
9   needEvent?: boolean,
10   children: React.ReactNode
11 }) {
12   const router = useRouter();
13   const [ok, setOk] = useState(false);
14 
15   useEffect(()=>{
16     const s = getSession();
17     if (!s.authed || !s.role) { router.replace("/login"); return; }
18     if (need !== "any" && s.role !== need) {
19       if (s.role === "admin") router.replace("/gestor"); else router.replace("/planilha");
20       return;
21     }
22     if (needEvent && !s.eventId) { router.replace("/gestor"); return; }
23     setOk(true);
24   }, [router, need, needEvent]);
25 
26   if (!ok) return null;
27   return <>{children}</>;
28 }

===== components/AppMenu.tsx =====
1 "use client";
2 
3 import Link from "next/link";
4 import { useEffect, useState } from "react";
5 import { clearSession, getSession } from "@/lib/session";
6 import { useRouter, usePathname } from "next/navigation";
7 import { listEvents } from "@/lib/events";
8 
9 export default function AppMenu() {
10   const router = useRouter();
11   const pathname = usePathname();
12   const [ready, setReady] = useState(false);
13   const [role, setRole] = useState<"admin" | "judge" | "coord" | null>(null);
14   const [eventId, setEventId] = useState<string | null>(null);
15   const [eventName, setEventName] = useState<string>("");
16 
17   useEffect(() => {
18     const s = getSession();
19     setRole(s.role);
20     setEventId(s.eventId);
21     setReady(true);
22 
23     async function loadEvent() {
24       if (s.eventId) {
25         try {
26           const events = await listEvents();
27           const ev = events.find((e) => e.id === s.eventId);
28           setEventName(ev?.name || "");
29         } catch (err) {
30           console.error("Erro ao carregar eventos:", err);
31         }
32       }
33     }
34 
35     loadEvent();
36   }, []);
37 
38   return (
39     <nav className="w-full border-b bg-white">
40       <div className="max-w-6xl mx-auto px-4 py-3 flex items-center justify-between gap-4">
41         <div className="font-semibold">CCR • Placar</div>
42         {!ready ? (
43           <div className="h-6 w-40 rounded bg-gray-200 animate-pulse" />
44         ) : role ? (
45           <div className="flex items-center gap-4 text-sm">
46             {role === "admin" ? (
47               <>
48                 <Link href="/gestor" className="hover:underline">
49                   Gestor
50                 </Link>
51                 {!!eventId && (
52                   <>
53                     <span
54                       className="text-gray-500 truncate max-w-[14rem]"
55                       title={eventName || eventId}
56                     >
57                       Evento: {eventName || eventId}
58                     </span>
59                     <Link href="/planilha" className="hover:underline">
60                       Planilha
61                     </Link>
62                     <Link href="/equipes" className="hover:underline">
63                       Equipes
64                     </Link>
65                     <Link href="/resultado" className="hover:underline">
66                       Resultado
67                     </Link>
68                     <Link href="/coordenacao" className="hover:underline">
69                       Coordenação
70                     </Link>
71                   </>
72                 )}
73               </>
74             ) : (
75               <>
76                 <Link href="/planilha" className="hover:underline">
77                   Planilha
78                 </Link>
79                 <Link href="/equipes" className="hover:underline">
80                   Equipes
81                 </Link>
82                 <Link href="/resultado" className="hover:underline">
83                   Resultado
84                 </Link>
85                 <Link href="/coordenacao" className="hover:underline">
86                   Coordenação
87                 </Link>
88               </>
89             )}
90             {pathname !== "/login" && (
91               <button
92                 onClick={() => {
93                   clearSession();
94                   router.push("/login");
95                 }}
96                 className="px-2 py-1 border rounded-md"
97               >
98                 Sair
99               </button>
100             )}
101           </div>
102         ) : (
103           <div className="text-sm">
104             {pathname !== "/login" && (
105               <Link href="/login" className="underline">
106                 Entrar
107               </Link>
108             )}
109           </div>
110         )}
111       </div>
112     </nav>
113   );
114 }

===== .env =====
1 DATABASE_URL="postgresql://neondb_owner:npg_k9KF4uVhNszL@ep-mute-pine-adcazqfg-pooler.c-2.us-east-1.aws.neon.tech/neondb?sslmode=require&channel_binding=require"
2 DIRECT_URL="postgresql://neondb_owner:npg_k9KF4uVhNszL@ep-mute-pine-adcazqfg.c-2.us-east-1.aws.neon.tech/neondb?sslmode=require&channel_binding=require"
3 ADMIN_MASTER_PIN="CCR-ADM-9073"

===== .env.local =====
1 DATABASE_URL="postgresql://neondb_owner:npg_k9KF4uVhNszL@ep-mute-pine-adcazqfg-pooler.c-2.us-east-1.aws.neon.tech/neondb?sslmode=require&channel_binding=require"
2 DIRECT_URL="postgresql://neondb_owner:npg_k9KF4uVhNszL@ep-mute-pine-adcazqfg.c-2.us-east-1.aws.neon.tech/neondb?sslmode=require&channel_binding=require"
3 ADMIN_MASTER_PIN="CCR-ADM-9073"

===== .env.example =====
1 DATABASE_URL="postgresql://user:password@host/dbname?sslmode=require&channel_binding=require"
2 DIRECT_URL="postgresql://user:password@host/dbname?sslmode=require&channel_binding=require"

===== package.json =====
1 {
2   "name": "ccr",
3   "private": true,
4   "version": "0.1.0",
5   "type": "module",
6   "scripts": {
7     "dev": "next dev --turbo",
8     "build": "next build",
9     "start": "next start",
10     "typecheck": "tsc --noEmit",
11     "postinstall": "prisma generate"
12   },
13   "dependencies": {
14     "next": "15.0.0",
15     "react": "19.0.0",
16     "react-dom": "19.0.0"
17   },
18   "devDependencies": {
19     "@prisma/client": "^6.18.0",
20     "@types/node": "^22.7.4",
21     "@types/react": "^19.0.0",
22     "autoprefixer": "^10.4.20",
23     "pg": "^8.16.3",
24     "postcss": "^8.4.47",
25     "prisma": "^6.18.0",
26     "tailwindcss": "^3.4.10",
27     "typescript": "^5.6.3"
28   }
29 }

===== tsconfig.json =====
1 {
2   "compilerOptions": {
3     "target": "ES2022",
4     "lib": [
5       "ES2022",
6       "DOM",
7       "DOM.Iterable"
8     ],
9     "module": "ESNext",
10     "moduleResolution": "Bundler",
11     "jsx": "preserve",
12     "resolveJsonModule": true,
13     "isolatedModules": true,
14     "noEmit": true,
15     "strict": true,
16     "baseUrl": ".",
17     "paths": {
18       "@/*": [
19         "./*"
20       ]
21     },
22     "skipLibCheck": true,
23     "allowJs": true,
24     "incremental": true,
25     "esModuleInterop": true,
26     "plugins": [
27       {
28         "name": "next"
29       }
30     ]
31   },
32   "include": [
33     "**/*.ts",
34     "**/*.tsx",
35     "next-env.d.ts",
36     ".next/types/**/*.ts"
37   ],
38   "exclude": [
39     "node_modules"
40   ]
41 }
