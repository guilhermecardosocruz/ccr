
===== app/api/admin-pin/route.ts =====
1 import prisma from "../../lib/prisma";
2 import { sha256Hex, genAlphaNum } from "../../lib/crypto";
3 
4 export const runtime = "nodejs";
5 export const dynamic = "force-dynamic";
6 
7 // GET: só informa se está configurado
8 export async function GET() {
9   const row = await prisma.appSetting.findUnique({ where: { key: "admin_pin_hash" } });
10   return Response.json({ ok: true, configured: Boolean(row?.value) });
11 }
12 
13 // POST: { adminPin?: string, rotate?: boolean } -> retorna adminPin só nessa resposta
14 export async function POST(req: Request) {
15   try {
16     const body = await req.json().catch(() => ({}));
17     let adminPin: string | undefined = body.adminPin ? String(body.adminPin).trim() : undefined;
18 
19     if (body.rotate || !adminPin) {
20       adminPin = genAlphaNum(10);
21     }
22 
23     await prisma.appSetting.upsert({
24       where: { key: "admin_pin_hash" },
25       create: { key: "admin_pin_hash", value: sha256Hex(adminPin) },
26       update: { value: sha256Hex(adminPin) },
27     });
28 
29     return Response.json({ ok: true, adminPin });
30   } catch {
31     return new Response(JSON.stringify({ ok: false, error: "bad_request" }), { status: 400 });
32   }
33 }

===== app/api/events/route.ts =====
1 import prisma from "../../lib/prisma";
2 import { sha256Hex, genNumeric, genAlphaNum } from "../../lib/crypto";
3 
4 export const runtime = "nodejs";
5 export const dynamic = "force-dynamic";
6 
7 // GET: lista eventos (id, name)
8 export async function GET() {
9   const rows = await prisma.event.findMany({
10     select: { id: true, name: true, createdAt: true, archived: true },
11     orderBy: { createdAt: "desc" },
12   });
13   return Response.json(rows);
14 }
15 
16 // POST: cria evento e já gera PINs padrão (retorna PINs em texto apenas nessa resposta)
17 export async function POST(req: Request) {
18   try {
19     const { name } = await req.json();
20     const n = String(name ?? "").trim();
21     if (!n) return new Response(JSON.stringify({ ok: false, error: "invalid_name" }), { status: 400 });
22 
23     const ev = await prisma.event.create({ data: { name: n } });
24 
25     // Gera PINs iniciais
26     const judgePin = genNumeric(6);
27     const coordPin = genAlphaNum(8);
28     await prisma.eventPins.create({
29       data: {
30         eventId: ev.id,
31         judgeHash: sha256Hex(judgePin),
32         coordHash: sha256Hex(coordPin),
33       },
34     });
35 
36     return Response.json({ ok: true, event: { id: ev.id, name: ev.name }, pins: { judgePin, coordPin } });
37   } catch (e: any) {
38     return new Response(JSON.stringify({ ok: false, error: "bad_request" }), { status: 400 });
39   }
40 }

===== app/api/events/[id]/pins/route.ts =====
1 import prisma from "../../../../lib/prisma";
2 import { sha256Hex, genAlphaNum, genNumeric } from "../../../../lib/crypto";
3 
4 export const runtime = "nodejs";
5 export const dynamic = "force-dynamic";
6 
7 // GET: retorna apenas que existem (não expõe plaintext)
8 export async function GET(_req: Request, { params }: { params: { id: string } }) {
9   const pins = await prisma.eventPins.findUnique({ where: { eventId: params.id } });
10   const hasJudge = Boolean(pins?.judgeHash);
11   const hasCoord = Boolean(pins?.coordHash);
12   return Response.json({ ok: true, hasJudge, hasCoord, rotatedAt: pins?.rotatedAt ?? null });
13 }
14 
15 /**
16  * POST: rotaciona ou define PINs
17  * body:
18  *  - rotate: boolean (se true, gera novos aleatórios)
19  *  - judgePin?: string  (opcional — define manual)
20  *  - coordPin?: string  (opcional — define manual)
21  * Retorna sempre os PINs em texto APENAS nessa resposta (para copiar).
22  */
23 export async function POST(req: Request, { params }: { params: { id: string } }) {
24   try {
25     const body = await req.json().catch(() => ({}));
26     let judgePin: string | undefined = body.judgePin ? String(body.judgePin).trim() : undefined;
27     let coordPin: string | undefined = body.coordPin ? String(body.coordPin).trim() : undefined;
28 
29     if (body.rotate) {
30       judgePin = genNumeric(6);
31       coordPin = genAlphaNum(8);
32     }
33     if (!judgePin && !coordPin) {
34       return new Response(JSON.stringify({ ok: false, error: "nothing_to_set" }), { status: 400 });
35     }
36 
37     // upsert
38     await prisma.eventPins.upsert({
39       where: { eventId: params.id },
40       create: {
41         eventId: params.id,
42         judgeHash: judgePin ? sha256Hex(judgePin) : null,
43         coordHash: coordPin ? sha256Hex(coordPin) : null,
44       },
45       update: {
46         judgeHash: judgePin ? sha256Hex(judgePin) : undefined,
47         coordHash: coordPin ? sha256Hex(coordPin) : undefined,
48         rotatedAt: new Date(),
49       },
50     });
51 
52     return Response.json({ ok: true, pins: { judgePin, coordPin } });
53   } catch (e: any) {
54     return new Response(JSON.stringify({ ok: false, error: "bad_request" }), { status: 400 });
55   }
56 }

===== app/api/events/[id]/runs/route.ts =====
1 export const runtime = "nodejs";
2 export const dynamic = "force-dynamic";
3 
4 import prisma from "../../../../../lib/prisma";
5 import { NextResponse } from "next/server";
6 
7 export async function GET(_req: Request, ctx: any) {
8   try {
9     const id: string | undefined = ctx?.params?.id;
10     if (!id) return NextResponse.json({ ok: false, error: "missing_id" }, { status: 400 });
11 
12     const runs = await prisma.run.findMany({
13       where: { eventId: id },
14       orderBy: { createdAt: "asc" },
15       select: {
16         id: true,
17         teamId: true,
18         score: true,
19         timeSec: true,
20         notes: true,
21         createdAt: true,
22       },
23     });
24 
25     return NextResponse.json({ ok: true, data: runs });
26   } catch (e: any) {
27     return NextResponse.json({ ok: false, error: e?.message || "internal_error" }, { status: 500 });
28   }
29 }
30 
31 export async function HEAD(_req: Request) {
32   return new Response(null, { status: 204 });
33 }

===== app/api/pin-login/route.ts =====
1 import prisma from "../../../lib/prisma";
2 import { sha256Hex } from "../../../lib/crypto";
3 
4 export const runtime = "nodejs";
5 export const dynamic = "force-dynamic";
6 
7 export async function POST(req: Request) {
8   try {
9     const { pin } = await req.json();
10     const p = String(pin ?? "").trim();
11     if (!p) return new Response(JSON.stringify({ ok: false, error: "missing_pin" }), { status: 400 });
12 
13     const h = sha256Hex(p);
14 
15     // 1) Admin?
16     const admin = await prisma.appSetting.findUnique({ where: { key: "admin_pin_hash" } });
17     if (admin?.value && admin.value === h) {
18       return Response.json({ ok: true, role: "admin", eventId: null });
19     }
20 
21     // 2) Procura pelos eventos e compara hashes
22     const pinsList = await prisma.eventPins.findMany({ select: { eventId: true, judgeHash: true, coordHash: true } });
23     for (const row of pinsList) {
24       if (row.judgeHash && row.judgeHash === h) {
25         return Response.json({ ok: true, role: "judge", eventId: row.eventId });
26       }
27       if (row.coordHash && row.coordHash === h) {
28         return Response.json({ ok: true, role: "coord", eventId: row.eventId });
29       }
30     }
31 
32     return new Response(JSON.stringify({ ok: false, error: "invalid_pin" }), { status: 401 });
33   } catch (e: any) {
34     return new Response(JSON.stringify({ ok: false, error: "bad_request" }), { status: 400 });
35   }
36 }
